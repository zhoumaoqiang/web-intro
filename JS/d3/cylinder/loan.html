<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>贷款增长情况</title>
  <style>
    .money.p5 {
      fill: #5757fd;
    }
    .money.p4 {
      fill: steelblue;
    }
    .money.p3 {
      fill: lightsteelblue;
    }
    .money.p2 {
      fill: #ccc;
    }
    .money.p1 {
      fill: #ddd;
    }
    .money.p0 {
      fill: #eee;
    }
    .tick line {
      stroke: #666;
      stroke-width: .5px;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <div id="charts"></div>
    <div class="color-index"></div>
  </div>
  <script src="../d3.v5.js"></script>
  <script>
    const DATA = [{
      "title": "manufacturing",
      "points": [6656,7593,10340,14019,14669,17147]
    }, {
      "title": "traffic",
      "points": [4163,6926,10237,11440,14607,14092]
    }, {
      "title": "house",
      "points": [3879,6020,11348,13789,27759,39358]
    }, {
      "title": "lifecost",
      "points": [3003,5019,5797,7135,7945,12950]
    }];
    const YEARS = ["2005","2008","2010","2012","2015","2017"];
    const DATAL = YEARS.length;
    // for(let i = 0; i < YEARS.length; i++) {
      
    // }
  </script>
  <script>
    window.onload = function() {
      let fullWidth = innerWidth - 40, chartHeight = 50;
      // 生成svg
      let g = d3
        .select("#charts")
        .selectAll("svg")
        .data(DATA)
        .enter()
        .append("svg")
        .attr("class", "loan-chart")
        .attr("width", fullWidth)
        .attr("height", chartHeight + 30)
        .append("g")
        .attr("transform", "translate(120, 0)")
        .attr("width", fullWidth - 200)
      
      // g.each((item, index) => {

        // 坐标轴，根据数值关系，直接去0-40000
        let xScale = d3.scaleLinear()
          .domain([0, 40]) 
          .range([0, fullWidth]);

        // 这个each只会遍历数据DATA, 生成条形图部分
        g.each((item, index) => {
          
          let singleG = d3.selectAll(`svg:nth-of-type(${index+1})`)
            .selectAll('g');

          let points = singleG
            .selectAll('rect.money')          
            .data(item.points.reverse()) // 由于绘制会覆盖，所以必须排序后反着绘制
            .enter().append("rect")
            .attr("class", function (d, i) {
              return "money p" + i;
            })
            .attr("width", (value) => {return Math.abs(value * fullWidth * 0.8 / 40000 - 0)})
            .attr("height", chartHeight - 20)
            .attr("x", 0)
            .attr("y", 20)


          // 生成文字
          let text = singleG.append("g")
            .style("text-anchor", "end")
            .attr("transform", "translate(-6, 40)")
            .append("text")
            .attr("class", "title")
            .text(item.title)
        })

        // 按照数字间隔生成坐标轴
        let tick = g.selectAll(`g.tick`)
          .data(xScale.ticks(10), function (d) {
            return xScale.tickFormat(10);
          });

        let tickIndexes = tick.enter()
          .append("g")
          .attr("class", "tick")
          .attr("transform", (indexes) => {return `translate(${xScale(indexes) * 0.8}, 0)`;})
          .style("opacity", 1e-6);  // 1e-6 == 0.000001

        tickIndexes.append("line")
          .attr("y1", chartHeight)
          .attr("y2", chartHeight * 7 / 6);
        
        tickIndexes.append("text")
          .attr("text-anchor", "middle")
          .attr("dy", "1em")
          .attr("y", chartHeight * 7 / 6)
          .text(xScale.tickFormat(10));

        tickIndexes.attr("transform", (indexes) => {return `translate(${xScale(indexes) * 0.8}, 0)`;})
          .style("opacity", 1);


      

    }
  </script>
</body>
</html>